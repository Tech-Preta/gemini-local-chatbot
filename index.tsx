/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

-import { GoogleGenAI, Chat } from '@google/genai';
+import { GoogleGenerativeAI } from '@google/generativeai';
import { marked } from 'marked';

// Extend the Window interface to include API_KEY
declare global {
  interface Window {
    API_KEY?: string;
  }
}

// API_KEY will be injected into the window object by env-config.js
// This file is generated by start-server.sh in Docker or created manually for local dev.
const API_KEY = window.API_KEY;

let chat: Chat | null = null;
let chatHistoryElement: HTMLElement | null = null;
let chatInputElement: HTMLInputElement | null = null;
let sendButtonElement: HTMLButtonElement | null = null;

let currentAiMessageElement: HTMLDivElement | null = null;
let accumulatedAiResponse = '';

/**
 * Displays a message in the chat history, rendering AI responses as markdown and user messages as plain text.
 *
 * @param text - The message content to display.
 * @param sender - Indicates whether the message is from the AI or the user.
 * @param isStreamingChunk - If true, appends the text as a streaming AI response; otherwise, displays as a complete message.
 *
 * @remark
 * AI messages are parsed and rendered as markdown, while user messages are shown as plain text. Streaming AI responses are accumulated and updated in a single message bubble.
 */
async function displayMessage(
  text: string,
  sender: 'ai' | 'user',
  isStreamingChunk = false
): Promise<void> {
  if (!chatHistoryElement) return;

  if (sender === 'ai') {
    if (isStreamingChunk) {
      accumulatedAiResponse += text;
      const htmlContent = await marked.parse(accumulatedAiResponse);
      if (!currentAiMessageElement) {
        currentAiMessageElement = document.createElement('div');
        currentAiMessageElement.classList.add('message', 'ai-message');
        currentAiMessageElement.setAttribute('role', 'article');
        currentAiMessageElement.setAttribute('aria-label', 'AI response');
        chatHistoryElement.appendChild(currentAiMessageElement);
      }
      currentAiMessageElement.innerHTML = htmlContent;
    } else {
      // Final non-streaming AI message or error
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', 'ai-message');
      messageDiv.innerHTML = await marked.parse(text);
      messageDiv.setAttribute('role', 'article');
      messageDiv.setAttribute('aria-label', 'AI response');
      chatHistoryElement.appendChild(messageDiv);
      currentAiMessageElement = null;
      accumulatedAiResponse = '';
    }
  } else {
    // User message
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', 'user-message');
    messageDiv.textContent = text; // User text isn't parsed as markdown
    messageDiv.setAttribute('role', 'article');
    messageDiv.setAttribute('aria-label', 'User message');
    chatHistoryElement.appendChild(messageDiv);
    // Reset AI message tracking when user sends a message
    currentAiMessageElement = null;
    accumulatedAiResponse = '';
  }

  chatHistoryElement.scrollTop = chatHistoryElement.scrollHeight;
}

/**
 * Enables or disables the chat input and send button based on loading state.
 *
 * @param isLoading - Whether the chat is currently processing a message.
 */
function setLoadingState(isLoading: boolean): void {
  if (chatInputElement) {
    chatInputElement.disabled = isLoading;
  }
  if (sendButtonElement) {
    sendButtonElement.disabled = isLoading;
    sendButtonElement.textContent = isLoading ? 'Sending...' : 'Send';
  }
}

/**
 * Handles sending the user's message to the AI and manages the display of both user and AI responses.
 *
 * Validates input and configuration, displays the user's message, streams and displays the AI's response in real time, and manages UI state and error handling throughout the process.
 */
async function handleSendMessage(): Promise<void> {
  if (!chatInputElement || !chat || !API_KEY) {
    if(!API_KEY) {
        console.error('API_KEY is not available on window object.');
        await displayMessage(
        '**Configuration Error:** API key is not loaded. Please check the console for details and ensure `env-config.js` is correctly set up.',
        'ai'
      );
    }
    return;
  }

  const userInput = chatInputElement.value.trim();
  if (!userInput) return;

  await displayMessage(userInput, 'user');
  chatInputElement.value = '';
  setLoadingState(true);

  try {
    const result = await chat.sendMessageStream(userInput); // Pass userInput directly
    for await (const chunk of result.stream) { // Iterate over result.stream
      const chunkText = chunk.text(); // Call chunk.text() as a function
      if (typeof chunkText === 'string') {
         await displayMessage(chunkText, 'ai', true);
      }
    }
  } catch (error) {
    console.error('Error sending message:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    await displayMessage(`Error: ${errorMessage}`, 'ai', false);
  } finally {
    currentAiMessageElement = null; // Finalize current AI message bubble
    accumulatedAiResponse = '';    // Reset accumulator
    setLoadingState(false);
    if (chatInputElement) chatInputElement.focus();
  }
}

/**
 * Initializes the chat application, setting up UI elements, event listeners, and the Gemini AI chat instance.
 *
 * Displays a welcome message on successful initialization. If required UI elements or the API key are missing, or if initialization fails, displays an error message and disables user input.
 */
async function initChatApp(): Promise<void> {
  chatHistoryElement = document.getElementById('chat-history');
  chatInputElement = document.getElementById('chat-input') as HTMLInputElement | null;
  sendButtonElement = document.getElementById('send-button') as HTMLButtonElement | null;

  if (!chatHistoryElement || !chatInputElement || !sendButtonElement) {
    console.error('Chat UI elements not found!');
    return;
  }

  if (!API_KEY) {
    await displayMessage(
      '**Error:** API key is not configured. Please ensure `env-config.js` is present and `window.API_KEY` is set. If using Docker, make sure `API_KEY` environment variable is passed during `docker run`.',
      'ai'
    );
    setLoadingState(true); // Disable input
    return;
  }

  try {
    const ai = new GoogleGenAI({ apiKey: API_KEY });
    chat = ai.chats.create({
      model: 'gemini-2.5-flash-preview-04-17',
      // config: {
      //   systemInstruction: "You are a helpful and friendly chatbot.",
      // },
    });

    sendButtonElement.addEventListener('click', handleSendMessage);
    chatInputElement.addEventListener('keypress', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        handleSendMessage();
      }
    });
    
    await displayMessage("Hello! I'm your Gemini-powered chatbot. How can I assist you today?", 'ai');
    chatInputElement.focus();

  } catch (error) {
    console.error('Failed to initialize chat:', error);
    const errorMessage = error instanceof Error ? error.message : 'Could not initialize AI chat service.';
    await displayMessage(`**Initialization Error:** ${errorMessage}`, 'ai');
    setLoadingState(true); // Disable input if init fails
  }
}

document.addEventListener('DOMContentLoaded', initChatApp);
